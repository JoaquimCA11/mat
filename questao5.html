<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Derivador — Correção e Desenvolvimento</title>

  <!-- mathjs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
  <!-- MathJax -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>

  <style>
    body{font-family: "Segoe UI", Roboto, Arial, sans-serif; max-width:980px;margin:24px auto;padding:20px;background:#f6f8fb;border-radius:10px}
    input[type=text]{width:100%;padding:10px;border-radius:8px;border:1px solid #d0d7df;font-size:1rem}
    button{padding:10px 14px;border-radius:8px;border:none;background:#246ef2;color:#fff;cursor:pointer}
    .box{background:#fff;padding:16px;border-radius:10px;margin-top:16px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
    .math{font-family: "Courier New", monospace;background:#fcfdff;padding:8px;border-radius:6px;display:block;margin:8px 0}
    pre{background:#f0f2f5;padding:10px;border-radius:8px;overflow:auto}
    .row{display:flex;gap:12px;align-items:flex-start}
    @media(max-width:600px){.row{flex-direction:column}}
    .small{color:#444;font-size:0.95rem}
  </style>
</head>
<body>
  <h1>Derivador — Correção e Desenvolvimento</h1>
  <p class="small">Use entradas amigáveis: <code>sqrt(x)</code>, <code>cbrt(x)</code>, <code>x^3</code>, <code>sen(x)</code>, <code>ln(x)</code>, <code>e^(...)</code>.</p>

  <div class="row">
    <div style="flex:1">
      <label>Função f(x): <input id="inp" type="text" placeholder="Ex: 5/(6*x^3) - 8*sqrt(x^3)"></label>
      <label>Opcional — avaliar f'(x) em: <input id="evalAt" type="text" placeholder="Ex: 2 (opcional)"></label>
      <div style="margin-top:8px">
        <button onclick="compute()">Calcular derivada (corrigido)</button>
        <button onclick="insertExample('5/(6*x^3) - 8*sqrt(x^3)')">Ex A</button>
        <button onclick="insertExample('2*cos(6*x)*sin(6*x)')">Ex B</button>
        <button onclick="insertExample('4*ln(x)/(3*x^4)')">Ex C</button>
        <button onclick="insertExample('e^(sqrt(x^2+1))')">Ex D</button>
      </div>
    </div>
  </div>

  <div id="out" class="box"></div>

<script>
/* ---------------- Normalização (amigável em celular) ---------------- */
function normalizeInput(raw){
  let s = String(raw || '');
  s = s.replace(/,/g,'.');
  s = s.replace(/\bsen\b/gi,'sin');
  s = s.replace(/√\s*\(?([a-zA-Z0-9_\)\(]+)\)?/g,'sqrt($1)');
  s = s.replace(/(\d)(\s*)([A-Za-z\(])/g,'$1*$3'); // 2x -> 2*x , 2sin -> 2*sin
  s = s.replace(/([A-Za-z\)])(\s*)(\d)/g,'$1*$3');   // x2 -> x*2
  s = s.replace(/\s+/g,' ');
  return s.trim();
}

/* ---------------- Helper: toTeX safe ---------------- */
function nodeToTexSafe(node){
  try{ return node.toTex({parenthesis:'keep'}); } catch(e){ return node.toString(); }
}

/* ---------------- Explanation builder ----------------
   Strategy:
   - Use mathjs to compute exact derivative for any node: math.derivative(node,'x')
   - For explanation, at each node we:
     * identify top-level rule (soma, produto, quociente, potencia, função)
     * compute derivatives of children via math.derivative(child,'x')
     * build LaTeX showing the rule and substitution with children's derivatives (as mathjs returned them)
   This ensures correctness (mathjs computes) and provides readable steps.
----------------------------------------------------------------- */

function explain(node){
  const type = node.type;

  if(type === 'ConstantNode'){
    return [{title: 'Constante', latex: `d/dx\\left(${nodeToTexSafe(node)}\\right)=0`}];
  }
  if(type === 'SymbolNode'){
    if(node.name === 'x'){
      return [{title: 'Variável', latex: `d/dx\\left(x\\right)=1`}];
    } else {
      return [{title: 'Constante simbólica', latex: `d/dx\\left(${nodeToTexSafe(node)}\\right)=0`}];
    }
  }

  if(type === 'OperatorNode'){
    const fn = node.fn;

    if(fn === 'add' || fn === 'subtract'){
      // derivative is sum/difference of derivatives
      const children = node.args;
      const childsExplanations = children.map(ch => {
        const dch = math.derivative(ch,'x');
        return {orig: nodeToTexSafe(ch), deriv: nodeToTexSafe(dch), node: ch};
      });
      // build latex showing sum of derivatives
      const left = nodeToTexSafe(node);
      const right = childsExplanations.map(c=>`\\left(${c.deriv}\\right)`).join(fn==='add' ? ' + ' : ' - ');
      const lines = [
        `Regra da soma: d(u\\pm v)=u'\\pm v'`,
        `u = ${nodeToTexSafe(children[0])}, v = ${nodeToTexSafe(children[1])} (se houver)`,
        `Aplicando: d\\left(${left}\\right) = ${right}`
      ];
      return [{title:'Soma/ Subtração', latex: lines.join(' \\\\ ')}].concat(children.flatMap(ch=>explain(ch)));
    }

    if(fn === 'multiply'){
      // product rule (binary) or general product rule
      const children = node.args;
      if(children.length === 2){
        const u = children[0], v = children[1];
        const du = math.derivative(u,'x'), dv = math.derivative(v,'x');
        const left = nodeToTexSafe(node);
        const latex = [
          `Regra do produto (2 fatores): d(uv)=u'v + u v'`,
          `u = ${nodeToTexSafe(u)},\\quad v = ${nodeToTexSafe(v)}`,
          `u' = ${nodeToTexSafe(du)},\\quad v' = ${nodeToTexSafe(dv)}`,
          `Aplicando: d\\left(${left}\\right) = ${nodeToTexSafe(du)}\\cdot ${nodeToTexSafe(v)} + ${nodeToTexSafe(u)} \\cdot ${nodeToTexSafe(dv)}`
        ];
        return [{title:'Produto', latex: latex.join(' \\\\ ')}].concat(explain(u), explain(v));
      } else {
        // general product rule: sum over i of u_i' * product_{j!=i} u_j
        const pieces = [];
        const latexLines = ['Regra do produto (n fatores): soma dos termos com um fator derivado.'];
        const terms = [];
        children.forEach((ch,i)=>{
          const dch = math.derivative(ch,'x');
          const others = children.map((o,j)=> j===i ? nodeToTexSafe(dch) : nodeToTexSafe(o)).join(' \\cdot ');
          terms.push(others);
          latexLines.push(`Termo ${i+1}: ${others}`);
        });
        latexLines.push(`Aplicando: d\\left(${nodeToTexSafe(node)}\\right) = ${terms.join(' + ')}`);
        return [{title:'Produto geral', latex: latexLines.join(' \\\\ ')}].concat(children.flatMap(ch=>explain(ch)));
      }
    }

    if(fn === 'divide'){
      const u = node.args[0], v = node.args[1];
      const du = math.derivative(u,'x'), dv = math.derivative(v,'x');
      const lines = [
        `Regra do quociente: d(u/v) = (u'v - u v')/v^2`,
        `u = ${nodeToTexSafe(u)},\\quad v = ${nodeToTexSafe(v)}`,
        `u' = ${nodeToTexSafe(du)},\\quad v' = ${nodeToTexSafe(dv)}`,
        `Aplicando: d\\left(${nodeToTexSafe(node)}\\right) = \\dfrac{${nodeToTexSafe(du)}\\cdot ${nodeToTexSafe(v)} - ${nodeToTexSafe(u)}\\cdot ${nodeToTexSafe(dv)}}{${nodeToTexSafe(v)}^{2}}`
      ];
      return [{title:'Quociente', latex: lines.join(' \\\\ ')}].concat(explain(u), explain(v));
    }

    if(node.op === '^'){
      const base = node.args[0], exp = node.args[1];
      // compute derivative with mathjs for accuracy
      const dbase = math.derivative(base,'x'), dexp = math.derivative(exp,'x');
      // decide rule text
      if(exp.type === 'ConstantNode'){
        const n = exp.value;
        const lines = [
          `Regra da potência: d(u^n) = n u^{n-1} u'`,
          `u = ${nodeToTexSafe(base)},\\quad n = ${n}`,
          `u' = ${nodeToTexSafe(dbase)}`,
          `Aplicando: d\\left(${nodeToTexSafe(node)}\\right) = ${n} \\cdot ${nodeToTexSafe(base)}^{${n-1}} \\cdot ${nodeToTexSafe(dbase)}`
        ];
        return [{title:'Potência (expoente constante)', latex: lines.join(' \\\\ ')}].concat(explain(base));
      } else {
        // general case via u^v -> u^v ( v' ln u + v u'/u )
        const lines = [
          'Caso geral: d(u^v) = u^v ( v\\\' ln u + v u\\\'/u )',
          `u = ${nodeToTexSafe(base)},\\quad v = ${nodeToTexSafe(exp)}`,
          `u' = ${nodeToTexSafe(dbase)},\\quad v' = ${nodeToTexSafe(dexp)}`,
          `Aplicando: d\\left(${nodeToTexSafe(node)}\\right) = ${nodeToTexSafe(node)} \\cdot \\left(${nodeToTexSafe(dexp)}\\cdot \\ln(${nodeToTexSafe(base)}) + ${nodeToTexSafe(exp)} \\cdot \\dfrac{${nodeToTexSafe(dbase)}}{${nodeToTexSafe(base)}}\\right)`
        ];
        return [{title:'Potência (caso geral)', latex: lines.join(' \\\\ ')}].concat(explain(base), explain(exp));
      }
    }
  }

  if(type === 'FunctionNode'){
    const name = node.name;
    const arg = node.args[0];
    const darg = math.derivative(arg,'x');
    // pick known outer derivative
    const mapping = {
      sin: ['cos(x)','d(sin(u))=cos(u) u\''],
      cos: ['-sin(x)','d(cos(u))=-sin(u) u\''],
      tan: ['sec(x)^2','d(tan(u))=sec^2(u) u\''],
      ln: ['1/x','d(ln(u))=u\'/u'],
      log: ['1/x','d(log(u))=u\'/u'],
      exp: ['exp(x)','d(exp(u))=exp(u) u\''],
      sqrt: ['1/(2 sqrt(x))','d(sqrt(u))=u\'/(2 sqrt(u))'],
      cbrt: ['1/(3 u^(2/3))','d(cbrt(u))=u\'/(3 u^{2/3})'],
      abs: ['sign(x)','d(|u|)=u\'/|u| (u≠0)']
    };
    const left = nodeToTexSafe(node);
    if(name in mapping){
      const lines = [
        `Regra da cadeia para ${name}: ${mapping[name][1]}`,
        `u = ${nodeToTexSafe(arg)}`,
        `u' = ${nodeToTexSafe(darg)}`,
        `Aplicando: d\\left(${left}\\right) = ${mapping[name][0].replace(/x/g, nodeToTexSafe(arg))} \\cdot ${nodeToTexSafe(darg)}`
      ];
      return [{title:`Função ${name}`, latex: lines.join(' \\\\ ')}].concat(explain(arg));
    } else {
      // fallback: show derivative computed by mathjs
      return [{title:'Função (fallback)', latex: `d\\left(${left}\\right) = ${nodeToTexSafe(math.derivative(node,'x'))}`}].concat(explain(arg));
    }
  }

  // fallback generic
  try{
    return [{title:'fallback', latex: `d(${nodeToTexSafe(node)}) = ${nodeToTexSafe(math.derivative(node,'x'))}`}];
  } catch(e){
    return [{title:'erro', latex: `Não foi possível explicar ${nodeToTexSafe(node)}`}];
  }
}

/* ---------------- Compute UI ---------------- */
function compute(){
  const raw = document.getElementById('inp').value;
  const at = document.getElementById('evalAt').value.trim();
  const out = document.getElementById('out');
  out.innerHTML = '';
  if(!raw){ out.innerHTML = '<b>Digite uma função.</b>'; return; }

  const norm = normalizeInput(raw);

  let parsed;
  try{ parsed = math.parse(norm); }
  catch(e){ out.innerHTML = '<b>Erro ao analisar a expressão:</b><br>' + e; return; }

  // derivative (mathjs accurate)
  let deriv, deriv_simp;
  try{
    deriv = math.derivative(parsed,'x');
    deriv_simp = math.simplify(deriv);
  } catch(e){
    out.innerHTML = '<b>Erro ao derivar:</b><br>' + e; return;
  }

  // build explanations
  const expl = explain(parsed); // array of steps (may include recursive pieces)

  // render
  let html = '';
  html += '<h3>Função informada</h3>';
  html += `<div class="math">$$f(x)=${nodeToTexSafe(parsed)}$$</div>`;

  html += '<h3>Derivada (exata)</h3>';
  html += `<div class="math">$$f\\\'(x) = ${nodeToTexSafe(deriv)}$$</div>`;

  html += '<h3>Derivada (simplificada)</h3>';
  html += `<div class="math">$$f\\\'(x) = ${nodeToTexSafe(deriv_simp)}$$</div>`;

  html += '<h3>Desenvolvimento (passos explicados)</h3>';
  expl.forEach((e,i)=>{
    html += `<div style="margin-bottom:12px"><b>Passo ${i+1} — ${e.title}:</b><div class="math">$$${e.latex}$$</div></div>`;
  });

  // evaluation if requested
  if(at !== ''){
    try{
      const xval = parseFloat(at);
      const val = deriv_simp.evaluate({x:xval});
      html += '<h3>Avaliação</h3>';
      html += `<div class="math">$$f\\\'(${xval}) = ${math.format(val, {precision:14})}$$</div>`;
    }catch(e){
      html += `<div class="small">Erro ao avaliar em x=${at}: ${e}</div>`;
    }
  }

  html += '<h3>LaTeX para copiar</h3>';
  html += `<pre>f(x) = ${parsed.toTex()}\n\nf'(x) = ${deriv_simp.toTex()}</pre>`;

  out.innerHTML = html;
  MathJax.typesetPromise();
}

/* quick inserts */
function insertExample(s){ document.getElementById('inp').value = s; }
</script>
</body>
</html>

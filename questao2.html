<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Questão — Área mínima (fórmulas livres, desenvolvimento detalhado)</title>

  <!-- math.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>

  <style>
    body{font-family:Segoe UI, Roboto, Arial; max-width:900px;margin:24px auto;padding:18px;background:#f6f8fb;border-radius:10px}
    label{display:block;margin-top:8px}
    input[type=text]{width:360px;padding:6px;border-radius:6px;border:1px solid #ccc}
    button{margin-top:8px;padding:8px 12px;border-radius:8px;border:none;background:#0b69ff;color:#fff;cursor:pointer}
    .box{background:#fff;padding:16px;border-radius:10px;margin-top:16px;box-shadow:0 8px 22px rgba(12,25,40,0.06)}
    pre{background:#f3f6fa;padding:10px;border-radius:8px;overflow:auto}
    .warn{color:#b04}
    table{border-collapse:collapse;width:100%;margin-top:8px}
    th,td{border:1px solid #ddd;padding:6px;text-align:right;font-family:monospace}
    th{background:#f0f2f5}
    .math{font-family: "Courier New", monospace; background:#f0f2f5; padding:4px 6px; border-radius:6px; display:inline-block}
  </style>
</head>
<body>
  <h1>Questão — Área mínima (use suas fórmulas)</h1>

  <label>Fórmula da área A( vars ): (ex: 2*pi*r^2 + 2*pi*r*h)</label>
  <input id="Aformula" type="text" value="2*pi*r^2 + 2*pi*r*h">

  <label>Fórmula do volume V( vars ): (ex: pi*r^2*h)</label>
  <input id="Vformula" type="text" value="pi*r^2*h">

  <label>Valor do volume (aceita 8192*pi, 8192π, expressões):</label>
  <input id="Vnum" type="text" placeholder="ex: 8192*pi">

  <button onclick="resolver()">Resolver</button>

  <div id="out" class="box"></div>

<script>
/* util */
function fmt(n, d=6){ return (Number.isFinite(n) ? parseFloat(n.toFixed(d)) : String(n)); }

function collectVars(node){
  const vars = new Set();
  node.traverse(function(n){
    if(n.isSymbolNode){
      const name = n.name;
      if(['pi','e','i','E','PI','sin','cos','tan','sqrt','log','exp'].includes(name)) return;
      vars.add(name);
    }
  });
  return Array.from(vars);
}

/* ========= RESOLVENDO dep numericamente (Newton) + registrar iterações ========= */
function solveDepNumericWithTrace(Vcompiled, indepName, depName, indepValue, Vnum){
  let y = Math.max(1, Math.abs(Vnum) ** (1/3));
  const iters = [];
  for(let i=0;i<60;i++){
    const scope = {}; scope[indepName] = indepValue; scope[depName] = y;
    const f = Vcompiled.evaluate(scope) - Vnum;

    // derivada parcial por diferença central
    const h = 1e-6;
    scope[depName] = y + h;
    const fph = Vcompiled.evaluate(scope);
    scope[depName] = y - h;
    const fmh = Vcompiled.evaluate(scope);
    const dfdh = (fph - fmh) / (2*h);

    iters.push({i, y: y, f: f, dfdh: dfdh});

    if(!Number.isFinite(f) || !Number.isFinite(dfdh)) break;
    if(Math.abs(dfdh) < 1e-14) break;

    const ynew = y - f/dfdh;
    if(!Number.isFinite(ynew)) break;
    if(Math.abs(ynew - y) < 1e-12) { y = ynew; break; }

    y = ynew;
    if(y <= 0) y = Math.abs(y) + 1e-6;
  }
  return {y, iters};
}

/* derivada numérica de função de 1 variável */
function derivada1(f, x){
  const h = 1e-6;
  return (f(x+h) - f(x-h)) / (2*h);
}

/* minimizar 1D com registro de iterações (Newton-like numérico) */
function minimize1DWithTrace(Afun, x0){
  let x = x0;
  const iters = [];
  for(let i=0;i<50;i++){
    const A_val = Afun(x);
    const d1 = derivada1(Afun, x);
    const d2 = (derivada1(Afun, x+1e-6) - d1) / 1e-6;
    iters.push({i, x, A_val, d1, d2});
    if(!Number.isFinite(d1) || !Number.isFinite(d2) || Math.abs(d2) < 1e-12) break;
    const xnew = x - d1/d2;
    if(!Number.isFinite(xnew)) break;
    if(Math.abs(xnew - x) < 1e-9) { x = xnew; break; }
    x = xnew;
    if(x <= 0) x = Math.abs(x) + 1e-6;
  }
  return {x, iters};
}

/* main */
function resolver(){
  const out = document.getElementById('out');
  out.innerHTML = '<p>Calculando…</p>';

  const Aform = document.getElementById('Aformula').value.trim();
  const Vform = document.getElementById('Vformula').value.trim();
  const VnumStr = document.getElementById('Vnum').value.trim();

  // avaliar Vnum com math.js (aceita 8192pi etc)
  let Vnum;
  try {
    Vnum = math.evaluate(VnumStr || '0');
  } catch(e){
    out.innerHTML = `<p class="warn"><b>Erro no volume:</b> expressão inválida.</p>`;
    return;
  }
  if(!Number.isFinite(Vnum) || Vnum <= 0){
    out.innerHTML = `<p class="warn"><b>Erro:</b> o volume numérico precisa ser um número positivo.</p>`;
    return;
  }

  // parsear expressões
  let Aroot, Vroot;
  try {
    Aroot = math.parse(Aform);
    Vroot = math.parse(Vform);
  } catch(e){
    out.innerHTML = `<p class="warn"><b>Erro:</b> fórmula inválida. Verifique sintaxe.</p>`;
    return;
  }

  // coletar variáveis usadas nas expressões
  const Avars = collectVars(Aroot);
  const Vvars = collectVars(Vroot);
  const allVars = Array.from(new Set([...Avars, ...Vvars]));

  if(allVars.length === 0){
    out.innerHTML = `<p class="warn"><b>Erro:</b> nenhuma variável detectada nas fórmulas.</p>`;
    return;
  }

  if(allVars.length === 1){
    out.innerHTML = `<p class="warn"><b>Atenção:</b> suas fórmulas usam apenas uma variável (${allVars[0]}). Para minimizar área precisa haver duas variáveis (ex: r e h, ou l e h).</p>`;
    return;
  }

  // escolher variável dependente (preferir 'h', senão a última variável)
  let depVar = allVars.includes('h') ? 'h' : (allVars.length>1 ? allVars[1] : null);
  let indepVar = allVars.find(v=>v!==depVar) || allVars[0];
  if(indepVar === depVar){
    indepVar = allVars.find(v=>v!==depVar) || indepVar;
  }

  const Acompiled = Aroot.compile();
  const Vcompiled = Vroot.compile();

  // função depFromIndep que também retorna iterações (aplicada para um x dado)
  function depFromIndepWithTrace(x){
    return solveDepNumericWithTrace(Vcompiled, indepVar, depVar, x, Vnum);
  }

  // construir A as função de indep
  function A_of_x(x){
    const y = depFromIndepWithTrace(x).y;
    const scope = {};
    scope[indepVar] = x;
    scope[depVar] = y;
    return Acompiled.evaluate(scope);
  }

  // chute inicial e minimização com trace
  let x0 = Math.cbrt(Math.abs(Vnum));
  if (!Number.isFinite(x0) || x0 <= 0) x0 = 1;

  // minimizar com trace
  const minimizeResult = minimize1DWithTrace(A_of_x, x0);
  const xMin = minimizeResult.x;
  const minimIters = minimizeResult.iters;

  // para o xMin, pegar a solução de dep e seu trace
  const depSolveAtMin = depFromIndepWithTrace(xMin);
  const yMin = depSolveAtMin.y;
  const depIters = depSolveAtMin.iters;

  const Amin = A_of_x(xMin);

  // Montar desenvolvimento detalhado
  let html = `<h2>Desenvolvimento detalhado (estilo prova)</h2>`;

  html += `<p><b>Dados:</b><br>A(${allVars.join(',')}) = <span class="math">${Aform}</span><br>V(${allVars.join(',')}) = <span class="math">${Vform}</span><br>Volume pedido: <span class="math">${VnumStr} = ${fmt(Vnum)}</span></p>`;

  html += `<h3>1) Isolar ${depVar} em função de ${indepVar}</h3>`;
  html += `<p>Impondo: <span class="math">${Vform} = ${VnumStr}</span></p>`;
  html += `<p>Como é difícil fazer simbolicamente para toda fórmula, aplicamos método numérico (Newton-Raphson) para resolver <span class="math">${Vform} = ${fmt(Vnum)}</span> fixando ${indepVar}.</p>`;

  html += `<h4>Exemplo de isolamento numérico (resolvendo ${depVar} para ${indepVar} = ${fmt(xMin)} — iterações):</h4>`;
  if(depIters.length){
    html += `<table><tr><th>it</th><th>${depVar}</th><th>f(${depVar}) = V(${indepVar},${depVar}) - Vnum</th><th>∂f/∂${depVar}</th></tr>`;
    depIters.forEach(r=>{
      html += `<tr><td>${r.i}</td><td>${fmt(r.y)}</td><td>${fmt(r.f)}</td><td>${fmt(r.dfdh)}</td></tr>`;
    });
    html += `</table>`;
  } else {
    html += `<p>Sem iterações registradas (resolução direta).</p>`;
  }

  html += `<p>Resultado numérico: <b>${depVar}(${indepVar}=${fmt(xMin)}) = ${fmt(yMin)}</b></p>`;

  html += `<h3>2) Construir A(${indepVar}) substituindo ${depVar}(${indepVar})</h3>`;
  html += `<p>Definimos <span class="math">A(${indepVar}) = A(${indepVar}, ${depVar}(${indepVar}))</span> e vamos minimizar essa função de uma variável.</p>`;

  html += `<h3>3) Minimização: derivada e condição de extremo (numérico)</h3>`;
  html += `<p>Derivamos numericamente A(${indepVar}) (diferença central) e aplicamos método de Newton para achar A'(${indepVar}) = 0.</p>`;

  html += `<h4>Iterações do método de minimização (x, A(x), A'(x), A'' estimada):</h4>`;
  if(minimIters.length){
    html += `<table><tr><th>it</th><th>${indepVar}</th><th>A(${indepVar})</th><th>A'(${indepVar})</th><th>A'' est.</th></tr>`;
    minimIters.forEach(r=>{
      html += `<tr><td>${r.i}</td><td>${fmt(r.x)}</td><td>${fmt(r.A_val)}</td><td>${fmt(r.d1)}</td><td>${fmt(r.d2)}</td></tr>`;
    });
    html += `</table>`;
  } else {
    html += `<p>Sem iterações registradas (chute inicial ou convergiu imediatamente).</p>`;
  }

  html += `<h3>4) Resultado</h3>`;
  html += `<p><b>${indepVar} que minimiza:</b> ${fmt(xMin)}</p>`;
  html += `<p><b>${depVar} correspondente (calculado por V = Vnum):</b> ${fmt(yMin)}</p>`;
  html += `<p><b>Área mínima encontrada:</b> ${fmt(Amin)}</p>`;

  html += `<h3>5) Verificação e observações</h3>`;
  html += `<p>Para verificar, podemos avaliar A em pontos próximos de ${fmt(xMin)} (por exemplo ${fmt(xMin*0.98)} e ${fmt(xMin*1.02)}) e conferir que A(${fmt(xMin)}) é menor.</p>`;

  // exemplo de verificação
  const Aleft = A_of_x(xMin*0.98);
  const Aright = A_of_x(xMin*1.02);
  html += `<p>Conferência numérica: A(${fmt(xMin*0.98)}) = ${fmt(Aleft)}, A(${fmt(xMin)}) = ${fmt(Amin)}, A(${fmt(xMin*1.02)}) = ${fmt(Aright)}</p>`;

  html += `<hr><p><b>Resumo final:</b></p>`;
  html += `<ul><li>${indepVar} = ${fmt(xMin)}</li><li>${depVar} = ${fmt(yMin)}</li><li>A mínima = ${fmt(Amin)}</li></ul>`;

  out.innerHTML = html;
}
</script>
</body>
</html>
